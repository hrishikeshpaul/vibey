{"ast":null,"code":"var _jsxFileName = \"/Users/samuelmunro/development/vibey/frontend/src/app/modules/Redirect/index.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect } from \"react\";\nimport { getQueryParams } from \"app/hooks/useQuery\";\nimport { useDispatch } from \"react-redux\";\nimport { getAuthorization } from \"app/store/user/userActions\";\nimport { useHistory } from \"react-router-dom\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Redirect = props => {\n  _s();\n\n  const dispatch = useDispatch();\n  const history = useHistory();\n  /*\n   * useEffect on initial render only\n   * pulls code and state from query\n   * calls getAuthorization (state api call with authorize() service) with code & state args\n   * authorize returns data from backend, res.data => state.auth.user\n   *\n   */\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        /*\n         * The following two lines can likely be aggregated & made into a custom hook\n         * will look into that soon.\n         *\n         */\n        const results = getQueryParams(props.location.search);\n        const [code, state] = [results.get(\"code\"), results.get(\"state\")];\n        dispatch(getAuthorization(code, state, history));\n      } catch (err) {\n        console.log(err); // The only promise is getAuthorization, which should inherently take care of error handling, so perhaps we don't need this catch?\n      }\n    };\n\n    fetchData();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: \"Redirecting...\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 38,\n    columnNumber: 10\n  }, this);\n};\n\n_s(Redirect, \"ttHHWC+EsJmhGbpqXwDwA2EruUw=\", false, function () {\n  return [useDispatch, useHistory];\n});\n\n_c = Redirect;\nexport default Redirect;\n\nvar _c;\n\n$RefreshReg$(_c, \"Redirect\");","map":{"version":3,"sources":["/Users/samuelmunro/development/vibey/frontend/src/app/modules/Redirect/index.tsx"],"names":["React","useEffect","getQueryParams","useDispatch","getAuthorization","useHistory","Redirect","props","dispatch","history","fetchData","results","location","search","code","state","get","err","console","log"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,cAAT,QAA+B,oBAA/B;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,gBAAT,QAAiC,4BAAjC;AACA,SAASC,UAAT,QAA2B,kBAA3B;;;AAEA,MAAMC,QAAQ,GAAIC,KAAD,IAAgB;AAAA;;AAC/B,QAAMC,QAAQ,GAAGL,WAAW,EAA5B;AACA,QAAMM,OAAO,GAAGJ,UAAU,EAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AAEEJ,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMS,SAAS,GAAG,YAAY;AAC5B,UAAI;AACF;AACR;AACA;AACA;AACA;AACQ,cAAMC,OAAO,GAAGT,cAAc,CAACK,KAAK,CAACK,QAAN,CAAeC,MAAhB,CAA9B;AACA,cAAM,CAACC,IAAD,EAAOC,KAAP,IAAgB,CAACJ,OAAO,CAACK,GAAR,CAAY,MAAZ,CAAD,EAAsBL,OAAO,CAACK,GAAR,CAAY,OAAZ,CAAtB,CAAtB;AACAR,QAAAA,QAAQ,CAACJ,gBAAgB,CAACU,IAAD,EAAOC,KAAP,EAAcN,OAAd,CAAjB,CAAR;AACD,OATD,CASE,OAAOQ,GAAP,EAAY;AACZC,QAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ,EADY,CAEZ;AACD;AACF,KAdD;;AAeAP,IAAAA,SAAS;AACV,GAjBQ,EAiBN,EAjBM,CAAT;AAmBA,sBAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAP;AACD,CAhCD;;GAAMJ,Q;UACaH,W,EACDE,U;;;KAFZC,Q;AAkCN,eAAeA,QAAf","sourcesContent":["import React, { useEffect } from \"react\";\nimport { getQueryParams } from \"app/hooks/useQuery\";\nimport { useDispatch } from \"react-redux\";\nimport { getAuthorization } from \"app/store/user/userActions\";\nimport { useHistory } from \"react-router-dom\";\n\nconst Redirect = (props: any) => {\n  const dispatch = useDispatch();\n  const history = useHistory();\n\n  /*\n   * useEffect on initial render only\n   * pulls code and state from query\n   * calls getAuthorization (state api call with authorize() service) with code & state args\n   * authorize returns data from backend, res.data => state.auth.user\n   *\n   */\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        /*\n         * The following two lines can likely be aggregated & made into a custom hook\n         * will look into that soon.\n         *\n         */\n        const results = getQueryParams(props.location.search);\n        const [code, state] = [results.get(\"code\"), results.get(\"state\")];\n        dispatch(getAuthorization(code, state, history));\n      } catch (err) {\n        console.log(err)\n        // The only promise is getAuthorization, which should inherently take care of error handling, so perhaps we don't need this catch?\n      }\n    };\n    fetchData();\n  }, []);\n\n  return <div>Redirecting...</div>;\n};\n\nexport default Redirect;\n"]},"metadata":{},"sourceType":"module"}