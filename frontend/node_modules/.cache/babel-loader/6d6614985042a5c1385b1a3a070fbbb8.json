{"ast":null,"code":"import { getLastItem } from \"./array\";\nimport { isArray, isNumber, isObject } from \"./assertion\";\nimport { fromEntries, objectKeys } from \"./object\";\nexport var breakpoints = Object.freeze([\"base\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\"]);\nexport function mapResponsive(prop, mapper) {\n  if (isArray(prop)) {\n    return prop.map(item => {\n      if (item === null) {\n        return null;\n      }\n\n      return mapper(item);\n    });\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result, key) => {\n      result[key] = mapper(prop[key]);\n      return result;\n    }, {});\n  }\n\n  if (prop != null) {\n    return mapper(prop);\n  }\n\n  return null;\n}\nexport function objectToArrayNotation(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var result = bps.map(br => {\n    var _obj$br;\n\n    return (_obj$br = obj[br]) != null ? _obj$br : null;\n  });\n\n  while (getLastItem(result) === null) {\n    result.pop();\n  }\n\n  return result;\n}\nexport function arrayToObjectNotation(values, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var result = {};\n  values.forEach((value, index) => {\n    var key = bps[index];\n    if (value == null) return;\n    result[key] = value;\n  });\n  return result;\n}\nexport function isResponsiveObjectLike(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n\n  var keys = Object.keys(obj);\n  return keys.length > 0 && keys.every(key => bps.includes(key));\n}\n/**\n * @note\n * The code below is the recommended way to analyze breakpoints\n * related stuff. Avoid using functions above, it'll be removed in the\n * next major\n */\n\nvar analyzeCSSValue = value => {\n  var num = parseFloat(value.toString());\n  var unit = value.toString().replace(String(num), \"\");\n  return {\n    unitless: !unit,\n    value: num,\n    unit\n  };\n};\n\nexport var px = value => {\n  if (value == null) return value;\n  var {\n    unitless\n  } = analyzeCSSValue(value);\n  return unitless || isNumber(value) ? value + \"px\" : value;\n};\n\nvar sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;\n\nvar sortBps = breakpoints => fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));\n\nfunction normalize(breakpoints) {\n  var sorted = sortBps(breakpoints);\n  return Object.assign(Object.values(sorted), sorted);\n}\n\nfunction keys(breakpoints) {\n  var value = Object.keys(sortBps(breakpoints));\n  return new Set(value);\n}\n\nfunction subtract(value) {\n  if (!value) return value;\n  value = px(value);\n  var factor = value.endsWith(\"px\") ? -1 : // the equivalent of 1px in em using a 16px base\n  -0.0635;\n  return isNumber(value) ? \"\" + (value + factor) : value.replace(/([0-9]+\\.?[0-9]*)/, m => \"\" + (parseFloat(m) + factor));\n}\n\nfunction queryString(min, max) {\n  var query = [];\n  if (min) query.push(\"@media screen and (min-width: \" + px(min) + \")\");\n  if (query.length > 0 && max) query.push(\"and\");\n  if (max) query.push(\"@media screen and (max-width: \" + px(max) + \")\");\n  return query.join(\" \");\n}\n\nexport function analyzeBreakpoints(breakpoints) {\n  var _breakpoints$base;\n\n  if (!breakpoints) return null;\n  breakpoints.base = (_breakpoints$base = breakpoints.base) != null ? _breakpoints$base : \"0px\";\n  var normalized = normalize(breakpoints);\n  var queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map((_ref, index, entry) => {\n    var _entry;\n\n    var [breakpoint, minW] = _ref;\n    var [, maxW] = (_entry = entry[index + 1]) != null ? _entry : [];\n    maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined;\n    return {\n      breakpoint,\n      minW,\n      maxW,\n      maxWQuery: queryString(null, maxW),\n      minWQuery: queryString(minW),\n      minMaxQuery: queryString(minW, maxW)\n    };\n  });\n\n  var _keys = keys(breakpoints);\n\n  var _keysArr = Array.from(_keys.values());\n\n  return {\n    keys: _keys,\n    normalized,\n\n    isResponsive(test) {\n      var keys = Object.keys(test);\n      return keys.length > 0 && keys.every(key => _keys.has(key));\n    },\n\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map(minW => queryString(minW)).slice(1)],\n\n    toArrayValue(test) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\");\n      }\n\n      var result = _keysArr.map(bp => {\n        var _test$bp;\n\n        return (_test$bp = test[bp]) != null ? _test$bp : null;\n      });\n\n      while (getLastItem(result) === null) {\n        result.pop();\n      }\n\n      return result;\n    },\n\n    toObjectValue(test) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\");\n      }\n\n      return test.reduce((acc, value, index) => {\n        var key = _keysArr[index];\n        if (key != null && value != null) acc[key] = value;\n        return acc;\n      }, {});\n    }\n\n  };\n}\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\n\nexport var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));","map":{"version":3,"sources":["../../src/responsive.ts"],"names":["breakpoints","Object","isArray","item","mapper","isObject","result","prop","bps","br","obj","getLastItem","values","key","value","keys","analyzeCSSValue","num","parseFloat","unit","String","unitless","px","isNumber","sortByBreakpointValue","parseInt","a","b","sortBps","fromEntries","sorted","factor","m","query","normalized","normalize","queries","entry","index","maxW","subtract","maxWQuery","queryString","minWQuery","minMaxQuery","_keys","_keysArr","Array","isResponsive","asObject","asArray","details","media","minW","toArrayValue","bp","test","toObjectValue","acc","isCustomBreakpoint","maybeBreakpoint","Number"],"mappings":"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","sourcesContent":["import { getLastItem } from \"./array\"\nimport { isArray, isNumber, isObject } from \"./assertion\"\nimport { fromEntries, objectKeys } from \"./object\"\nimport { Dict } from \"./types\"\n\nexport const breakpoints = Object.freeze([\n  \"base\",\n  \"sm\",\n  \"md\",\n  \"lg\",\n  \"xl\",\n  \"2xl\",\n])\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map((item) => {\n      if (item === null) {\n        return null\n      }\n      return mapper(item)\n    })\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key])\n      return result\n    }, {})\n  }\n\n  if (prop != null) {\n    return mapper(prop)\n  }\n\n  return null\n}\n\nexport function objectToArrayNotation(obj: Dict, bps = breakpoints) {\n  const result = bps.map((br) => obj[br] ?? null)\n  while (getLastItem(result) === null) {\n    result.pop()\n  }\n  return result\n}\n\nexport function arrayToObjectNotation(values: any[], bps = breakpoints) {\n  const result = {} as Dict\n  values.forEach((value, index) => {\n    const key = bps[index]\n    if (value == null) return\n    result[key] = value\n  })\n  return result\n}\n\nexport function isResponsiveObjectLike(obj: Dict, bps = breakpoints) {\n  const keys = Object.keys(obj)\n  return keys.length > 0 && keys.every((key) => bps.includes(key))\n}\n\n/**\n * @note\n * The code below is the recommended way to analyze breakpoints\n * related stuff. Avoid using functions above, it'll be removed in the\n * next major\n */\n\nconst analyzeCSSValue = (value: number | string) => {\n  const num = parseFloat(value.toString())\n  const unit = value.toString().replace(String(num), \"\")\n  return { unitless: !unit, value: num, unit }\n}\n\nexport const px = (value: number | string): string => {\n  if (value == null) return value\n  const { unitless } = analyzeCSSValue(value)\n  return unitless || isNumber(value) ? `${value}px` : value\n}\n\nconst sortByBreakpointValue = (a: any[], b: any[]) =>\n  parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1\n\nconst sortBps = (breakpoints: Dict): Dict =>\n  fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue))\n\nfunction normalize(breakpoints: Dict) {\n  const sorted = sortBps(breakpoints)\n  return Object.assign(Object.values(sorted), sorted) as string[]\n}\n\nfunction keys(breakpoints: Dict) {\n  const value = Object.keys(sortBps(breakpoints))\n  return new Set(value)\n}\n\nfunction subtract(value: string) {\n  if (!value) return value\n  value = px(value)\n  const factor = value.endsWith(\"px\")\n    ? -1\n    : // the equivalent of 1px in em using a 16px base\n      -0.0635\n  return isNumber(value)\n    ? `${value + factor}`\n    : value.replace(/(\\d+\\.?\\d*)/u, (m) => `${parseFloat(m) + factor}`)\n}\n\nfunction queryString(min: string | null, max?: string) {\n  const query = []\n\n  if (min) query.push(`@media screen and (min-width: ${px(min)})`)\n  if (query.length > 0 && max) query.push(\"and\")\n  if (max) query.push(`@media screen and (max-width: ${px(max)})`)\n\n  return query.join(\" \")\n}\n\nexport function analyzeBreakpoints(breakpoints: Dict) {\n  if (!breakpoints) return null\n\n  breakpoints.base = breakpoints.base ?? \"0px\"\n\n  const normalized = normalize(breakpoints)\n\n  const queries = Object.entries(breakpoints)\n    .sort(sortByBreakpointValue)\n    .map(([breakpoint, minW], index, entry) => {\n      let [, maxW] = entry[index + 1] ?? []\n      maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined\n      return {\n        breakpoint,\n        minW,\n        maxW,\n        maxWQuery: queryString(null, maxW),\n        minWQuery: queryString(minW),\n        minMaxQuery: queryString(minW, maxW),\n      }\n    })\n\n  const _keys = keys(breakpoints)\n  const _keysArr = Array.from(_keys.values())\n\n  return {\n    keys: _keys,\n    normalized,\n    isResponsive(test: Dict) {\n      const keys = Object.keys(test)\n      return keys.length > 0 && keys.every((key) => _keys.has(key))\n    },\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map((minW) => queryString(minW)).slice(1)],\n    toArrayValue(test: Dict) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\")\n      }\n      const result = _keysArr.map((bp) => test[bp] ?? null)\n      while (getLastItem(result) === null) result.pop()\n      return result\n    },\n    toObjectValue(test: any[]) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\")\n      }\n      return test.reduce((acc, value, index) => {\n        const key = _keysArr[index]\n        if (key != null && value != null) acc[key] = value\n        return acc\n      }, {} as Dict)\n    },\n  }\n}\n\nexport type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"]},"metadata":{},"sourceType":"module"}